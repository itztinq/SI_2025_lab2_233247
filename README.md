# Мартина Стојановска, бр. на индекс 233247

## Control Flow Graph
![cfg](https://github.com/user-attachments/assets/0dbebe57-5a19-40ad-a3c0-13d26dad77aa)

## Цикломатска комплексност
Цикломатската комплексност е дефинирана со формулата `V(G) = E - N + 2`, каде што:
- E е бројот на ребра во CFG,
- N е бројот на јазли во CFG.

Во овој случај имаме 31 ребро и 24 јазли, па пресметката е: `V(G) = 31 - 24 + 2 = 9`

Оттука добиваме дека цикломатската комплексност на кодот изнесува 9.

## Тест случаи според критериумот Every statement
![Image](https://github.com/user-attachments/assets/8c7155fa-8d81-494c-8b9d-12bb44b0ac5a)

Првиот тест случај со null листа ја активира линијата `А` каде се проверува дали листата е null, што веднаш води до фрлање исклучок во линијата `B`, прекинувајќи го извршувањето.

Вториот тест со item што има null име ги поминува линиите `C` за иницијализација на сумата, `D1-D3` за влез во for-циклусот, `E` за проверка на името и `F` каде се фрла исклучок поради невалидно име.

Третиот тест случај, кој вклучува item со цена над 300 и попуст, ги опфаќа сите клучни линии за пресметка: `G` каде се проверуваат условите за цена, попуст и количина; `H` каде се одзема 30; `I-J` за пресметка со попуст; и `L-O` за валидација на картичката, завршувајќи со враќање на сумата во `R`.

Четвртиот тест со валиден item но невалидна должина на картичката ја активира линијата `K` за стандардна пресметка без попуст, `L` за проверка на должина и `Q` каде се фрла исклучок за невалидна должина.

Петтиот тест за невалиден знак во картичката ги опфаќа линиите `M` за иницијализација на дозволените знаци, `N1-N3` за итерација низ картичката, `O` за откривање на невалиден знак и `P` каде се фрла соодветен исклучок.

На овој начин, секоја линија од кодот е опфатена барем еднаш, со тестови што систематски ги проверуваат основните функционалности, граничните случаи и сите можни исклучоци.

## Тест случаи според критериумот Multiple Condition
![Image](https://github.com/user-attachments/assets/717fbf7e-7b3c-4c2d-9263-bb6e869f8cda)

Првиот тест случај `(F||F||F)` со цена 100, попуст 0 и количина 1 не ги исполнува ниту еден од условите, па не се одземаат 30 и се врши стандардна пресметка.

Вториот случај `(F||F||T)` со количина 11 го активира третиот услов, предизвикувајќи одземање на 30 но без примена на попуст.

Третиот тест `(F||T||F)` со попуст 0.2 го активира вториот услов, што резултира со одземање на 30 и примена на попуст врз цената.

Четвртиот случај `(F||T||T)` комбинира попуст и голема количина, активирајќи два услови и додавајќи ги нивните ефекти.

Петтиот тест `(T||F||F)` со цена 400 го активира првиот услов, додека шестиот `(T||F||T)` ја комбинира високата цена со големата количина.

Седмиот случај `(T||T||F)` проверува комбинација на висока цена и попуст, а осмиот `(T||T||T)` ги активира сите три услови истовремено, проверувајќи ја целосната логика.

На овој начин се проверуваат сите можни комбинации на услови, обезбедувајќи дека секој дел од сложената логика е правилно имплементиран и дека сите релевантни сценарија се обработуваат како што се очекува.

## Објаснување на напишаните unit tests

### Every Statement тестови

Во рамки на критериумот Every Statement, целта е да се обезбеди извршување на секоја линија од кодот барем еднаш. Методот `checkCart()` од класата `SILab2` е тестиран преку пет независни unit тестови, секој со специфичен влез и очекувано однесување.

- Тест 1: Влез → `allItems = null`  
  Овој тест симулира случај кога на методот му се проследува `null` наместо валидна листа на артикли. Целта е да се потврди дека методот правилно фрла `RuntimeException` со цел да се спречи понатамошна обработка врз неиницијализирани податоци. Со овој тест се покриваат почетните линии во кои се врши валидација на влезот.

- Тест 2: Влез → `List.of(new Item(null, 1, 100, 0.0))`  
  Овој тест случај испраќа листа со еден артикл чиј `name е null`. Методот треба да фрли `RuntimeException` бидејќи името на артиклот е задолжителен податок. Со ова се покрива блокот кој ги валидира атрибутите на секој елемент во листата.

- Тест 3: Влез → `List.of(new Item("Laptop", 1, 400, 0.1))`  
  Овој тест проверува точноста на пресметката. Артиклот има цена над 300 и има попуст од 10%. Според логиката на методот, треба да се одземе фиксна сума од 30 и потоа да се пресмета попустот:
  `-30 + 400 * (1 - 0.1) * 1 = -30 + 360 = 330.0.` Со овој тест се активираат сите услови поврзани со цената и попустот.

- Тест 4: Влез → `List.of(new Item("Phone", 1, 100, 0.0)), број на картичка: "1234"`  
  Овде се симулира валиден артикл, но `невалиден број на картичка` (со должина помала од 16 цифри). Методот треба да фрли `RuntimeException` бидејќи картичките мора да имаат точно 16 цифри. Се покрива блокот што ја валидира должината на картичката.

- Тест 5: Влез → `List.of(new Item("Book", 1, 100, 0.0)), број на картичка: "1234abcd9012#$%6"`  
  Во овој случај бројот на картичката содржи `невалидни знаци`: букви и специјални знаци. Методот треба да фрли `RuntimeException` затоа што се дозволени само бројки. Со овој тест се покрива гранката која проверува дали бројот на картичката е составен исклучиво од цифри.

Со овие тест случаи се обезбедува целосно покривање на сите извршливи линии од методот `checkCart()` и се проверуваат и гранични и типични сценарија што ја зголемува доверливоста во исправноста на имплементацијата.

### Multiple Condition тестови

Во рамки на критериумот Multiple Condition, целта е да се тестираат сите можни комбинации на поединечни услови во една композитна логичка изјава. Во методот `checkCart()` постои услов од формата:
```java
if (item.getPrice() > 300 || item.getQuantity() > 10 || item.getDiscount() > 0)
```
Овој услов има три независни логички подуслови поврзани со операторот || (логичко ИЛИ). За да се оствари целосна MCC покриеност, потребни се `2³ = 8` различни комбинации на вредности, што резултира со 8 тест случаи.

- Тест 1: Влез → `Item(price=100, quantity=1, discount=0.0)`  
  Комбинација: `F || F || F` → Резултат: `false`   
  Сите три услови се false. Затоа не се применува одземање на 30 и се пресметува само основната цена:  
  100 * 1 = 100.0

- Тест 2: Влез → `Item(price=100, quantity=1, discount=0.2)`  
  Комбинација: `F || F || T` → Резултат: `true`   
  Се активира условот поради попустот и се одзема 30, а се применува и попуст:  
  -30 + 100 * (1 - 0.2) * 1 = 50.0

- Тест 3: Влез → `Item(price=100, quantity=11, discount=0.0)`  
  Комбинација: `F || T || F` → Резултат: `true`   
  Се активира условот поради количината и се одзема 30 од вкупната цена:  
  -30 + 100 * 11 = 1070.0

- Тест 4: Влез → `Item(price=100, quantity=11, discount=0.1)`  
  Комбинација: `F || T || T` → Резултат: `true`   
  Се активира условот поради количината и попустот, се одзема 30 и се пресметува со попустот:  
  -30 + 100 * (1 - 0.1) * 11 = 960.0

- Тест 5: Влез → `Item(price=400, quantity=1, discount=0.0)`  
  Комбинација: `T || F || F` → Резултат: `true`   
  Се активира условот поради цената, и се одзема 30:  
  -30 + 400 = 370.0

- Тест 6: Влез → `Item(price=400, quantity=1, discount=0.2)`  
  Комбинација: `T || F || T` → Резултат: `true`   
  Се активира условот поради цената и попустот, па се одзема 30 и се применува попуст:  
  -30 + 400 * (1 - 0.2) * 1 = 290.0

- Тест 7: Влез → `Item(price=400, quantity=11, discount=0.0)`  
  Комбинација: `T || T || F` → Резултат: `true`   
  Се активира условот поради цената и количината, па се одзема 30 и се пресметува без попуст:  
  -30 + 400 * 11 = 4370.0

- Тест 8: Влез → `Item(price=500, quantity=20, discount=0.5)`  
  Комбинација: `T || T || T` → Резултат: `true`   
  Сите услови се активни. Се одзема 30 и се применува попуст на вкупната количина:  
  -30 + 500 * (1 - 0.5) * 20 = 4970.0

Со овие осум тест случаи се покриваат сите можни комбинации на вистинитост за три логички услови поврзани со `||`, што го задоволува Multiple Condition критериумот во целост. Овој пристап гарантира дека логиката на методот ќе се однесува правилно во сите сценарија, вклучувајќи гранични и сложени комбинации на вредности.

Важно е да се истакне дека Java користи `lazy evaluation` (или short-circuit evaluation) при извршување на логичките оператори како `||`. Ова значи дека евалуацијата на условите се прекинува штом се пронајде првиот услов што е `true`, а преостанатите услови не се евалуираат.

Поради ова однесување, во практична примена се доволни `4 тест случаи` за целосно покривање на логичката функционалност:
- по еден тест случај каде секој поединечен услов независно го активира блокот, и
- еден тест случај каде сите услови се `false` и блокот не се извршува.
